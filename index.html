<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <!-- iPhone WebApp full screen -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Vaisseau">
  <title>Vaisseau â€” iPhone WebApp</title>
  <style>
    :root{
      --bg:#05070d;--panel:#0b111a;--grid:#101525;--text:#eaf1ff;--muted:#9bb0c9;--accent:#6dd6ff;--ok:#9bff9b;--warn:#ffd166;--danger:#ff6d83;
    }
    *{box-sizing:border-box;-webkit-user-select:none;user-select:none}
    html,body{height:100%;}
    body{margin:0;background:radial-gradient(900px 700px at 50% -10%, #0a1430, #05070d);color:var(--text);font-family:System-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial,sans-serif;overflow:hidden;-webkit-tap-highlight-color:transparent}
    .hud{position:fixed;top:0;left:0;right:0;display:flex;justify-content:space-between;gap:8px;padding:10px 12px;color:var(--muted);font-size:14px;z-index:5;pointer-events:none}
    .chip{border:1px solid #1b2432;background:#0e1522;border-radius:999px;padding:6px 8px;pointer-events:auto}
    canvas{position:fixed;inset:0;display:block;}

    /* Touch controls */
    .controls{position:fixed;inset:0;pointer-events:none}
    .stick{position:absolute;left:14px;bottom:18px;width:120px;height:120px;border-radius:999px;border:1px solid #1b2432;background:rgba(15,22,34,.35);backdrop-filter:blur(2px);pointer-events:auto}
    .stick .nub{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:56px;height:56px;border-radius:999px;border:1px solid #1b2432;background:rgba(20,28,44,.9)}
    .fire{position:absolute;right:18px;bottom:26px;width:84px;height:84px;border-radius:999px;border:1px solid #1b2432;background:rgba(20,28,44,.35);display:grid;place-items:center;font-weight:800;color:#ffd166;pointer-events:auto}
    .autofire{position:absolute;right:22px;bottom:128px}
    .pause{position:absolute;right:22px;top:22px}

    .btn{appearance:none;border:1px solid #1b2432;background:#0f1622;color:var(--text);border-radius:12px;padding:8px 10px;pointer-events:auto}
    .toast{position:fixed;left:50%;bottom:24px;transform:translateX(-50%);background:rgba(16,24,38,.9);border:1px solid #1b2432;border-radius:12px;padding:8px 12px;display:none;z-index:10}
    .toast.show{display:block}

    .overlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:9;background:rgba(5,7,13,.5)}
    .card{background:linear-gradient(180deg,#111a2a,#0c1421);border:1px solid #1b2432;border-radius:16px;padding:16px 18px;text-align:center;max-width:340px}
    .title{font-weight:800;margin-bottom:6px}
  </style>
</head>
<body>
  <canvas id="game" width="420" height="780" aria-label="Jeu de vaisseau spatial"></canvas>
  <div class="hud">
    <div class="chip">Score: <b id="score">0</b></div>
    <div class="chip">Vies: <b id="lives">3</b></div>
    <div class="chip">Niveau: <b id="level">1</b></div>
  </div>
  <div class="controls">
    <div class="stick" id="stick"><div class="nub" id="nub"></div></div>
    <button class="fire" id="fire">ðŸ”¥</button>
    <button class="btn autofire" id="btnAuto">Auto: OFF</button>
    <button class="btn pause" id="btnPause">Pause</button>
  </div>

  <div class="overlay" id="overlay">
    <div class="card">
      <div class="title" id="ovTitle">Pause</div>
      <div id="ovHint" style="color:var(--muted)">Touchez Â« Reprendre Â» pour continuer</div>
      <div style="margin-top:10px;display:flex;gap:8px;justify-content:center">
        <button class="btn" id="btnResume">Reprendre</button>
        <button class="btn" id="btnRestart">Rejouer</button>
      </div>
    </div>
  </div>

  <div class="toast" id="toast"></div>

<script>
// ===== Helpers
const $=s=>document.querySelector(s);
function toast(m){ const t=$('#toast'); t.textContent=m; t.classList.add('show'); setTimeout(()=>t.classList.remove('show'),1000); }
function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }

// ===== Canvas sizing (portrait mobile)
const cvs = $('#game'); const ctx = cvs.getContext('2d');
function resize(){
  const w = window.innerWidth, h = window.innerHeight; // portrait expected
  const targetRatio = 420/780; // design base
  let cw = w, ch = h;
  if(cw/ch > targetRatio){ cw = ch*targetRatio; } else { ch = cw/targetRatio; }
  cvs.style.width = cw+'px'; cvs.style.height = ch+'px';
  // keep internal resolution fixed for simplicity; could scale for retina if needed
}
window.addEventListener('resize', resize); resize();

// ===== Game State
const state = {
  running:true, paused:false,
  score:0, lives:3, level:1,
  player:{ x:210, y:650, vx:0, vy:0, speed:240, cooldown:0 },
  bullets:[], enemies:[], particles:[], powerups:[],
  spawnTimer:0, spawnRate:1.0, autoFire:false,
};

// ===== Input (virtual stick + fire)
const stick = $('#stick'); const nub = $('#nub'); const fireBtn = $('#fire');
let stickActive=false, stickCenter={x:0,y:0}, stickVec={x:0,y:0};
function getPos(e){ const r=stick.getBoundingClientRect(); const p=(e.touches? e.touches[0]: e); return {x:p.clientX - r.left, y:p.clientY - r.top} }
function startStick(e){ stickActive=true; const r=stick.getBoundingClientRect(); stickCenter={x:r.width/2,y:r.height/2}; moveStick(e); }
function moveStick(e){ if(!stickActive) return; const p=getPos(e); const dx=p.x-stickCenter.x, dy=p.y-stickCenter.y; const max=48; let len=Math.hypot(dx,dy); const k = len>0? Math.min(1, len/max):0; stickVec={ x: (dx/ (len||1)) * k, y: (dy/ (len||1)) * k}; nub.style.transform = `translate(${(stickCenter.x + stickVec.x*max)-28}px, ${(stickCenter.y + stickVec.y*max)-28}px)`; }
function endStick(){ stickActive=false; stickVec={x:0,y:0}; nub.style.transform='translate(-50%,-50%)'; }
stick.addEventListener('pointerdown', e=>{ e.preventDefault(); startStick(e); });
stick.addEventListener('pointermove', e=>{ e.preventDefault(); moveStick(e); });
stick.addEventListener('pointerup', endStick); stick.addEventListener('pointercancel', endStick); stick.addEventListener('pointerleave', e=>{ if(!e.buttons) endStick(); });

let firing=false; fireBtn.addEventListener('pointerdown', ()=>{ firing=true; fire(); });
window.addEventListener('pointerup', ()=>{ firing=false; });
$('#btnAuto').onclick = ()=>{ state.autoFire=!state.autoFire; $('#btnAuto').textContent = 'Auto: ' + (state.autoFire?'ON':'OFF'); toast(state.autoFire?'Auto ON':'Auto OFF'); };
$('#btnPause').onclick = ()=> pause(true);
$('#btnResume').onclick = ()=> pause(false);
$('#btnRestart').onclick = restart;

// ===== Entities
function spawnEnemy(){
  const type = Math.random()<0.75? 'basic':'sine';
  const x = 30 + Math.random()*(cvs.width-60); const y=-20;
  const speed = 50 + Math.random()*60 + state.level*4;
  const hp = type==='basic'? 1 : 2;
  state.enemies.push({x,y, vx:0, vy:speed, type, t:0, hp});
}

function fire(){ if(state.player.cooldown>0) return; state.bullets.push({x:state.player.x, y:state.player.y-18, vy:-420, r:3}); state.player.cooldown = 0.16; }

function explode(x,y,color='#a0eaff',n=10){ for(let i=0;i<n;i++){ const a=Math.random()*Math.PI*2; const s=60+Math.random()*120; state.particles.push({x,y, vx:Math.cos(a)*s, vy:Math.sin(a)*s, life:0.6}); } }

// ===== Update & Draw
let last=0;
function loop(ts){ if(!state.running) return; const t=ts/1000; const dt = last? Math.min(0.033, t-last): 0; last=t; if(!state.paused){ update(dt); draw(); } requestAnimationFrame(loop); }

function update(dt){
  // player
  state.player.vx = stickVec.x * state.player.speed;
  state.player.vy = stickVec.y * state.player.speed;
  state.player.x = clamp(state.player.x + state.player.vx*dt, 20, cvs.width-20);
  state.player.y = clamp(state.player.y + state.player.vy*dt, 80, cvs.height-20);
  state.player.cooldown = Math.max(0, state.player.cooldown - dt);
  if((firing || state.autoFire) && state.player.cooldown===0) fire();

  // bullets
  for(const b of state.bullets){ b.y += b.vy*dt; }
  state.bullets = state.bullets.filter(b=> b.y>-10);

  // enemies spawn
  state.spawnTimer -= dt; if(state.spawnTimer<=0){ state.spawnTimer = Math.max(0.2, 1.2 - state.level*0.06); spawnEnemy(); }
  for(const e of state.enemies){
    e.t += dt; if(e.type==='sine'){ e.x += Math.sin(e.t*3.2)*40*dt; }
    e.y += e.vy*dt; if(e.y>cvs.height+40){ loseLife(); removeEnemy(e); }
  }
  // collisions
  for(const e of [...state.enemies]){
    for(const b of [...state.bullets]){
      if(Math.hypot(e.x-b.x, e.y-b.y)<18){ // hit
        e.hp--; state.bullets.splice(state.bullets.indexOf(b),1);
        if(e.hp<=0){ explode(e.x,e.y); addScore(10); removeEnemy(e); maybeLevelUp(); }
        break;
      }
    }
    // player collision
    if(Math.hypot(e.x-state.player.x, e.y-state.player.y)<26){ explode(e.x,e.y,'#ff6d83',14); removeEnemy(e); loseLife(); }
  }

  // particles
  for(const p of state.particles){ p.life -= dt; p.x += p.vx*dt; p.y += p.vy*dt; }
  state.particles = state.particles.filter(p=>p.life>0);
}

function removeEnemy(e){ const i=state.enemies.indexOf(e); if(i>=0) state.enemies.splice(i,1); }
function addScore(n){ state.score += n; $('#score').textContent = state.score; }
function maybeLevelUp(){ const newLevel = 1 + Math.floor(state.score/120); if(newLevel!==state.level){ state.level=newLevel; $('#level').textContent = state.level; toast('Niveau '+state.level+' â†‘'); } }
function loseLife(){ state.lives--; $('#lives').textContent = state.lives; if(state.lives<=0){ gameOver(); } else { toast('Ouch ! -1 vie'); } }

function draw(){
  // background grid
  ctx.clearRect(0,0,cvs.width,cvs.height);
  const g=ctx.createLinearGradient(0,0,0,cvs.height); g.addColorStop(0,'#0b111a'); g.addColorStop(1,'#080d15'); ctx.fillStyle=g; ctx.fillRect(0,0,cvs.width,cvs.height);
  ctx.strokeStyle='#101525'; ctx.lineWidth=1; ctx.globalAlpha=0.8; for(let y=0;y<cvs.height;y+=26){ ctx.beginPath(); ctx.moveTo(0.5,y+0.5); ctx.lineTo(cvs.width+0.5,y+0.5); ctx.stroke(); } ctx.globalAlpha=1;

  // player ship
  drawShip(state.player.x, state.player.y, '#6dd6ff');

  // bullets
  ctx.fillStyle='#a5ff6a'; for(const b of state.bullets){ ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fill(); }

  // enemies
  for(const e of state.enemies){ drawEnemy(e); }

  // particles
  ctx.fillStyle='rgba(160,234,255,.9)'; for(const p of state.particles){ ctx.globalAlpha = Math.max(0,p.life/0.6); ctx.fillRect(p.x-2,p.y-2,4,4); } ctx.globalAlpha=1;
}

function drawShip(x,y,color){
  ctx.save(); ctx.translate(x,y); ctx.fillStyle=color; ctx.beginPath();
  ctx.moveTo(0,-18); ctx.lineTo(14,16); ctx.lineTo(0,8); ctx.lineTo(-14,16); ctx.closePath(); ctx.fill();
  // glow
  ctx.strokeStyle='rgba(109,214,255,.5)'; ctx.lineWidth=2; ctx.stroke(); ctx.restore();
}

function drawEnemy(e){
  ctx.save(); ctx.translate(e.x,e.y); const c = e.type==='sine'? '#ff6db2':'#ffd166';
  ctx.fillStyle=c; ctx.beginPath(); ctx.moveTo(0,-14); ctx.lineTo(12,12); ctx.lineTo(-12,12); ctx.closePath(); ctx.fill();
  ctx.restore();
}

function pause(show){ state.paused=show; $('#overlay').style.display = show? 'flex':'none'; $('#ovTitle').textContent = show? 'Pause' : ''; }
function restart(){ state.score=0; state.lives=3; state.level=1; $('#score').textContent=0; $('#lives').textContent=3; $('#level').textContent=1; state.enemies.length=0; state.bullets.length=0; state.particles.length=0; state.player.x=cvs.width/2; state.player.y=650; state.spawnTimer=0; pause(false); toast('Bonne chance !'); }
function gameOver(){ state.paused=true; $('#overlay').style.display='flex'; $('#ovTitle').textContent='Game Over'; $('#ovHint').textContent='Rejouer pour tenter un meilleur score'; }

requestAnimationFrame(loop);
</script>
</body>
</html>
